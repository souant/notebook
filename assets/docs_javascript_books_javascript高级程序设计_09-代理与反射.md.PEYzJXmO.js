import{_ as s,c as i,o as a,a3 as e}from"./chunks/framework.ymtTkBEb.js";const g=JSON.parse('{"title":"代理与反射","description":"","frontmatter":{},"headers":[],"relativePath":"docs/javascript/books/javascript高级程序设计/09-代理与反射.md","filePath":"docs/javascript/books/javascript高级程序设计/09-代理与反射.md"}'),t={name:"docs/javascript/books/javascript高级程序设计/09-代理与反射.md"},n=e(`<h1 id="代理与反射" tabindex="-1">代理与反射 <a class="header-anchor" href="#代理与反射" aria-label="Permalink to &quot;代理与反射&quot;">​</a></h1><h2 id="代理" tabindex="-1">代理 <a class="header-anchor" href="#代理" aria-label="Permalink to &quot;代理&quot;">​</a></h2><p>代理可视为目标对象的替身</p><p>使用 Proxy 构造函数创建</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> target</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  foo: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;bar&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> handler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;intercepted&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 代理</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> proxy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target, hanlder);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(proxy.foo); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// intercepted</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target.foo); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// bar</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 撤销代理</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">revoke</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Proxy.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">revocable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target, handler);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(proxy.foo); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// intercepted</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target.foo); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// bar</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">revoke</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(proxy.foo); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// TypeError</span></span></code></pre></div><h2 id="反射" tabindex="-1">反射 <a class="header-anchor" href="#反射" aria-label="Permalink to &quot;反射&quot;">​</a></h2><p>所有<strong>捕获器</strong>都可以基于自己的参数重建原始操作行为，手动修改<strong>捕获器</strong>可能会导致这些原始行为被破坏</p><p>处理程序对象中所有可以捕获的方法都有对应的反射（<strong>Reflect</strong>）API 方法。这些方法与捕获器拦截的方法具有相同的名称和函数签名，而且也具有与被拦截方法相同的行为</p><h2 id="捕获器" tabindex="-1">捕获器 <a class="header-anchor" href="#捕获器" aria-label="Permalink to &quot;捕获器&quot;">​</a></h2><p>一共13 种不同的捕获器</p><ol><li><code>get()</code> 捕获器会在获取属性值的操作中被调用。对应的反射 API 方法为 Reflect.get()</li><li><code>set()</code> 捕获器会在设置属性值的操作中被调用。对应的反射 API 方法为 Reflect.set()</li><li><code>has()</code> 捕获器会在 in 操作符中被调用。对应的反射 API 方法为 Reflect.has()</li><li><code>defineProperty()</code> 捕获器会在 Object.defineProperty()中被调用。对应的反射 API 方法为Reflect.defineProperty()</li><li><code>getOwnPropertyDescriptor()</code> 捕获器会在 Object.getOwnPropertyDescriptor()中被调用。对应的反射 API 方法为 Reflect.getOwnPropertyDescriptor()</li><li><code>deleteProperty()</code> 捕获器会在 delete 操作符中被调用。对应的反射 API 方法为 Reflect.deleteProperty()</li><li><code>ownKeys()</code> 捕获器会在 Object.keys()及类似方法中被调用。对应的反射 API 方法为 Reflect.ownKeys()</li><li><code>getPrototypeOf()</code> 捕获器会在 Object.getPrototypeOf()中被调用。对应的反射 API 方法为Reflect.getPrototypeOf()</li><li><code>setPrototypeOf()</code> 捕获器会在 Object.setPrototypeOf()中被调用。对应的反射 API 方法为Reflect.setPrototypeOf()</li><li><code>isExtensible()</code> 捕获器会在 Object.isExtensible()中被调用。对应的反射 API 方法为Reflect.isExtensible()</li><li><code>preventExtensions()</code> 捕获器会在 Object.preventExtensions()中被调用。对应的反射 API方法为 Reflect.preventExtensions()</li><li><code>apply()</code> 捕获器会在调用函数时中被调用。对应的反射 API 方法为 Reflect.apply()</li><li><code>construct()</code> 捕获器会在 new 操作符中被调用。对应的反射 API 方法为 Reflect.construct()</li></ol>`,11),l=[n];function p(h,k,r,o,d,c){return a(),i("div",null,l)}const y=s(t,[["render",p]]);export{g as __pageData,y as default};
