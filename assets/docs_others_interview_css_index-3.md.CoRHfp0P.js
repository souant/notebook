import{_ as i,c as l,o as e,a3 as t}from"./chunks/framework.ymtTkBEb.js";const k=JSON.parse('{"title":"高级","description":"","frontmatter":{},"headers":[],"relativePath":"docs/others/interview/css/index-3.md","filePath":"docs/others/interview/css/index-3.md"}'),a={name:"docs/others/interview/css/index-3.md"},s=t(`<h1 id="高级" tabindex="-1">高级 <a class="header-anchor" href="#高级" aria-label="Permalink to &quot;高级&quot;">​</a></h1><h2 id="对-bfc-规范-块级格式化上下文-block-formatting-context-的理解" tabindex="-1">对 BFC 规范(块级格式化上下文：block formatting context)的理解？ <a class="header-anchor" href="#对-bfc-规范-块级格式化上下文-block-formatting-context-的理解" aria-label="Permalink to &quot;对 BFC 规范(块级格式化上下文：block formatting context)的理解？&quot;">​</a></h2><p>先来看两个相关的概念</p><p>Box: Box 是 CSS 布局的对象和基本单位，⼀个⻚⾯是由很多个 Box 组成的，这个 Box 就是我们所说的盒模型。</p><p>Formatting context：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤。</p><p>BFC 的特点：</p><ul><li>垂直方向上，自上而下排列，和文档流的排列方式一致。</li><li>在 BFC 中上下相邻的两个容器的 margin 会重叠</li><li>计算 BFC 的高度时，需要计算浮动元素的高度</li><li>BFC 区域不会与浮动的容器发生重叠</li><li>BFC 是独立的容器，容器内部元素不会影响外部元素</li><li>每个元素的左 margin 值和容器的左 border 相接触</li></ul><p>满足下列条件之一就可触发 BFC</p><ul><li>根元素：<code>body</code>；</li><li>元素设置浮动：<code>float</code> 除 none 以外的值；</li><li>元素设置绝对定位：<code>position (absolute、fixed)</code>；</li><li><code>display</code> 值为：<code>inline-block、table-cell、table-caption、flex</code> 等；</li><li><code>overflow</code> 值为：<code>hidden、auto、scroll</code>；</li></ul><p>BFC 的作用</p><ul><li>解决 margin 的重叠问题：由于 BFC 是一个独立的区域，内部的元素和外部的元素互不影响，将两个元素变为两个 BFC，就解决了 margin 重叠的问题。</li><li>解决高度塌陷的问题：在对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为 0。解决这个问题，只需要把父元素变成一个 BFC。常用的办法是给父元素设置 overflow:hidden。</li><li>创建自适应两栏布局：可以用来创建自适应两栏布局：左边的宽度固定，右边的宽度自适应</li></ul><h2 id="link-和-import-的区别" tabindex="-1">link 和@import 的区别 <a class="header-anchor" href="#link-和-import-的区别" aria-label="Permalink to &quot;link 和@import 的区别&quot;">​</a></h2><p>两者都是外部引用 CSS 的方式，它们的区别如下：</p><ul><li>link 是 XHTML 标签，除了加载 CSS 外，还可以定义 RSS 等其他事务；@import 属于 CSS 范畴，只能加载 CSS。</li><li>link 引用 CSS 时，在页面载入时同时加载；@import 需要页面网页完全载入以后加载。</li><li>link 是 XHTML 标签，无兼容问题；@import 是在 CSS2.1 提出的，低版本的浏览器不支持。</li><li>link 支持使用 Javascript 控制 DOM 去改变样式；而@import 不支持。</li></ul><h2 id="display-none-与-visibility-hidden-的区别" tabindex="-1">display:none 与 visibility:hidden 的区别 <a class="header-anchor" href="#display-none-与-visibility-hidden-的区别" aria-label="Permalink to &quot;display:none 与 visibility:hidden 的区别&quot;">​</a></h2><p>这两个属性都是让元素隐藏，不可见。两者区别如下：</p><ol><li>在渲染树中</li></ol><ul><li>display:none 会让元素完全从渲染树中消失，渲染时不会占据任何空间；</li><li>visibility:hidden 不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。</li></ul><ol start="2"><li>是否是继承属性</li></ol><ul><li>display:none 是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；</li><li>visibility:hidden 是继承属性，子孙节点消失是由于继承了 hidden，通过设置 visibility:visible 可以让子孙节点显示；</li></ul><ol start="3"><li><p>修改常规文档流中元素的 display 通常会造成文档的重排，但是修改 visibility 属性只会造成本元素的重绘；</p></li><li><p>如果使用读屏器，设置为 display:none 的内容不会被读取，设置为 visibility:hidden 的内容会被读取。</p></li></ol><h2 id="为什么有时候用-translate-来改变位置而不是定位" tabindex="-1">为什么有时候⽤ translate 来改变位置⽽不是定位？ <a class="header-anchor" href="#为什么有时候用-translate-来改变位置而不是定位" aria-label="Permalink to &quot;为什么有时候⽤ translate 来改变位置⽽不是定位？&quot;">​</a></h2><p>改变 transform 或 opacity 不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）</p><p>transform 使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。</p><p>因此 translate()更⾼效，可以缩短平滑动画的绘制时间。 ⽽ translate 改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况</p><h2 id="常见的图片格式及使用场景" tabindex="-1">常见的图片格式及使用场景 <a class="header-anchor" href="#常见的图片格式及使用场景" aria-label="Permalink to &quot;常见的图片格式及使用场景&quot;">​</a></h2><ol><li><code>BMP</code>，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以 BMP 格式的图片通常是较大的文件。</li><li><code>GIF</code>，是无损的、采用索引色的点阵图。采用 LZW 压缩算法进行编码。文件小，是 GIF 格式的优点，同时，GIF 格式还具有支持动画以及透明的优点。但是 GIF 格式仅支持 8bit 的索引色，所以 GIF 格式适用于对色彩要求不高同时需要文件体积较小的场景。</li><li><code>JPEG</code>，是有损的、采用直接色的点阵图。JPEG 的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG 非常适合用来存储照片，与 GIF 相比，JPEG 不适合用来存储企业 Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较 GIF 更大。</li><li><code>PNG-8</code>，是无损的、使用索引色的点阵图。PNG 是一种比较新的图片格式，PNG-8 是非常好的 GIF 格式替代者，在可能的情况下，应该尽可能的使用 PNG-8 而不是 GIF，因为在相同的图片效果下，PNG-8 具有更小的文件体积。除此之外，PNG-8 还支持透明度的调节，而 GIF 并不支持。除非需要动画的支持，否则没有理由使用 GIF 而不是 PNG-8。</li><li><code>PNG-24</code>，是无损的、使用直接色的点阵图。PNG-24 的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24 格式的文件大小要比 BMP 小得多。当然，PNG24 的图片还是要比 JPEG、GIF、PNG-8 大得多。</li><li><code>SVG</code>，是无损的矢量图。SVG 是矢量图意味着 SVG 图片由直线和曲线以及绘制它们的方法组成。当放大 SVG 图片时，看到的还是线和曲线，而不会出现像素点。SVG 图片在放大时，不会失真，所以它适合用来绘制 Logo、Icon 等。</li><li><code>WebP</code>，是谷歌开发的一种新图片格式，WebP 是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为 Web 而生的，什么叫为 Web 而生呢？就是说相同质量的图片，WebP 具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有 Chrome 浏览器和 Opera 浏览器支持 WebP 格式，兼容性不太好。</li></ol><ul><li>在无损压缩的情况下，相同质量的 WebP 图片，文件大小要比 PNG 小 26%；</li><li>在有损压缩的情况下，具有相同图片精度的 WebP 图片，文件大小要比 JPEG 小 25%~34%；</li><li>WebP 图片格式支持图片透明度，一个无损压缩的 WebP 图片，如果要支持透明度只需要 22%的格外文件大小。</li></ul><h2 id="css-优化和提高性能的方法有哪些" tabindex="-1">CSS 优化和提高性能的方法有哪些 <a class="header-anchor" href="#css-优化和提高性能的方法有哪些" aria-label="Permalink to &quot;CSS 优化和提高性能的方法有哪些&quot;">​</a></h2><ul><li><p>加载性能：</p><ol><li>css 压缩：将写好的 css 进行打包压缩，可以减小文件体积。</li><li>css 单一样式：当需要下边距和左边距的时候，很多时候会选择使用 margin:top 0 bottom 0；但 margin-bottom:bottom;margin-left:left;执行效率会更高。</li><li>减少使用<code>@import</code>，建议使用 link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。</li></ol></li><li><p>选择器性能：</p><ol><li>关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS 选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；</li><li>如果规则拥有 ID 选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。</li><li>避免使用通配规则，如*{}计算次数惊人，只对需要用到的元素进行选择。</li><li>尽量少的去对标签进行选择，而是用 class。</li><li>尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。</li><li>了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。</li></ol></li><li><p>渲染性能：</p><ol><li>慎重使用高性能属性：浮动、定位。</li><li>尽量减少页面重排、重绘。</li><li>去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少 css 文档体积。</li><li>属性值为 0 时，不加单位。</li><li>属性值为浮动小数 0.**，可以省略小数点之前的 0。</li><li>标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</li><li>不使用@import 前缀，它会影响 css 的加载速度。</li><li>选择器优化嵌套，尽量避免层级过深。</li><li>css 雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。</li><li>正确使用 display 的属性，由于 display 的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。</li><li>不滥用 web 字体。对于中文网站来说 WebFonts 可能很陌生，国外却很流行。web fonts 通常体积庞大，而且一些浏览器在下载 web fonts 时会阻塞页面渲染损伤性能。</li></ol></li></ul><h2 id="sass、less-是什么-为什么要使用他们" tabindex="-1">Sass、Less 是什么？为什么要使用他们？ <a class="header-anchor" href="#sass、less-是什么-为什么要使用他们" aria-label="Permalink to &quot;Sass、Less 是什么？为什么要使用他们？&quot;">​</a></h2><p>他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。</p><h2 id="flex-布局" tabindex="-1">Flex 布局 <a class="header-anchor" href="#flex-布局" aria-label="Permalink to &quot;Flex 布局&quot;">​</a></h2><p>使用 <code> display: flex; | display: inline-flex;</code> 定义弹性盒子</p><p>flex 盒子定义属性：</p><ul><li><code>flex-direction: row | row-reverse | column | column-reverse; </code> 定义主轴方向</li><li><code>flex-wrap: nowrap | wrap | wrap-reverse;</code> 定义主轴方向如何换行</li><li><code>flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;</code> 默认值为<code>row nowrap</code></li><li><code>justify-content: flex-start | flex-end | center | space-between | space-around;</code> 定义在主轴上的对齐方式</li><li><code>align-items: flex-start | flex-end | center | baseline | stretch;</code> 定义在交叉轴上如何对齐</li><li><code>align-content: flex-start | flex-end | center | space-between | space-around | stretch;</code> 定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用</li></ul><p>flex item 定义属性：</p><ul><li><code>order: &lt;integer&gt;;</code> 定义项目的排列顺序。数值越小，排列越靠前，默认为 0</li><li><code>flex-grow: &lt;number&gt;; /* default 0 */</code> 定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大</li><li><code>flex-shrink: &lt;number&gt;; /* default 1 */</code> 定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小</li><li><code>flex-basis: &lt;length&gt; | auto; /* default auto */</code> 定义了在分配多余空间之前，项目占据的主轴空间（main size）</li><li><code>flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]</code> <code>flex-grow, flex-shrink 和 flex-basis</code>的简写，默认值为<code>0 1 auto</code> 后两个属性可选</li><li><code>align-self: auto | flex-start | flex-end | center | baseline | stretch;</code> 允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch</li></ul><h2 id="grid-网格布局" tabindex="-1">Grid 网格布局 <a class="header-anchor" href="#grid-网格布局" aria-label="Permalink to &quot;Grid 网格布局&quot;">​</a></h2><p><code>display: grid; display: inline-grid;</code>指定一个容器采用网格布局</p><p>划分<code>行</code>和<code>列</code>:</p><ul><li><code>grid-template-columns: 100px 100px 100px;</code> 三列, 列宽 100px</li><li><code>grid-template-rows: 100px 100px 100px;</code> 三行, 行高 100px</li></ul><ol><li>repeat()</li></ol><p>重复写同样的值非常麻烦，尤其网格很多时。这时，可以使用 repeat()函数，简化重复的值</p><ul><li><code>grid-template-columns: repeat(3, 100px);</code> 三列, 列宽 100px</li><li><code>grid-template-rows: repeat(3, 100px);</code> 三行, 行高 100px</li></ul><ol start="2"><li>auto-fill 关键字</li></ol><p>有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用 auto-fill 关键字表示自动填充 <code>grid-template-columns: repeat(auto-fill, 100px);</code></p><ol start="3"><li><p>fr 关键字 如果两列的宽度分别为 1fr 和 2fr，就表示后者是前者的两倍 <code>grid-template-columns: 1fr 1fr;</code></p></li><li><p>minmax() minmax()函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值 <code>grid-template-columns: 1fr 1fr minmax(100px, 1fr);</code></p></li><li><p>auto 关键字<br> auto 关键字表示由浏览器自己决定长度。 <code>grid-template-columns: 100px auto 100px;</code></p></li><li><p>网格线的名称</p></li></ol><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">grid-template-columns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">c1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] 100px [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">c2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] 100px [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">c3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] auto [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">c4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">grid-template-rows</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">r1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] 100px [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">r2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] 100px [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">r3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] auto [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">r4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span></code></pre></div><ul><li><p><code>grid-gap</code> 属性是 grid-column-gap 和 grid-row-gap 的合并简写形式，语法如下</p></li><li><p><code>grid-template-areas</code> 网格布局允许指定&quot;区域&quot;（area），一个区域由单个或多个单元格组成。grid-template-areas 属性用于定义区域</p></li><li><p><code>grid-auto-flow </code> 划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是&quot;先行后列&quot;，即先填满第一行，再开始放入第二行</p></li><li><p><code>justify-items: start | end | center | stretch;</code> justify-items 属性设置单元格内容的水平位置（左中右），</p></li><li><p><code>align-items: start | end | center | stretch;</code> align-items 属性设置单元格内容的垂直位置（上中下）</p></li><li><p><code>place-items: &lt;align-items&gt; &lt;justify-items&gt;; </code> place-items 属性是 align-items 属性和 justify-items 属性的合并简写形式</p></li></ul>`,50),o=[s];function d(r,n,c,p,h,u){return e(),l("div",null,o)}const g=i(a,[["render",d]]);export{k as __pageData,g as default};
