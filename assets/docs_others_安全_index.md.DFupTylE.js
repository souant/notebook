import{_ as e,c as o,o as l,a3 as a}from"./chunks/framework.ymtTkBEb.js";const _=JSON.parse('{"title":"安全","description":"","frontmatter":{},"headers":[],"relativePath":"docs/others/安全/index.md","filePath":"docs/others/安全/index.md"}'),t={name:"docs/others/安全/index.md"},i=a('<h1 id="安全" tabindex="-1">安全 <a class="header-anchor" href="#安全" aria-label="Permalink to &quot;安全&quot;">​</a></h1><h2 id="前端安全" tabindex="-1">前端安全 <a class="header-anchor" href="#前端安全" aria-label="Permalink to &quot;前端安全&quot;">​</a></h2><h3 id="_1-sql注入" tabindex="-1">1. SQL注入 <a class="header-anchor" href="#_1-sql注入" aria-label="Permalink to &quot;1. SQL注入&quot;">​</a></h3><p>SQL 注入漏洞（SQL Injection）是 Web 开发中最常见的一种安全漏洞。</p><blockquote><p>主要是利用前端表单提交，比如输入框、富文本框，输入sql语句提交到后端，当后端服务通过提交的字段拼接成sql语句进行数据库查询的时候，恶意sql被执行，从而达到攻击的目的</p></blockquote><p>防御措施：</p><ul><li>转义过滤用户的输入的某些 sql 关键字，如<code>select、from、and、or</code>等。</li><li>使用ORM框架如MyBatis，减少sql的手动拼接。</li></ul><h3 id="_2-xss跨站点脚本攻击" tabindex="-1">2. XSS跨站点脚本攻击 <a class="header-anchor" href="#_2-xss跨站点脚本攻击" aria-label="Permalink to &quot;2. XSS跨站点脚本攻击&quot;">​</a></h3><blockquote><p>XSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的</p></blockquote><blockquote><p>XSS 一般分为<code>存储型</code>、<code>反射型</code>和 <code>DOM 型</code>。</p></blockquote><p>防御措施：</p><ul><li><p>尽量少使用 .innerHTML、.outerHTML、document.write()，如果用 Vue/React 技术栈，尽量少使用 v-html/dangerouslySetInnerHTML 功能。如果一定要使用的话一定要避免在字符串中拼接不可信数据，把用户输入的 &amp; &lt; &gt; &quot; &#39; / 等字符转义掉。</p></li><li><p>设置cookie为HttpOnly。被设置了httpOnly的cookie字段无法通过JS获取，也就降低了XSS攻击时用户凭据隐私泄漏的风险。</p></li><li><p>开启CSP防护。内容安全策略（CSP）的设计就是为了防御XSS攻击的，通过在HTTP头部或meta中设置Content-Security-Policy，就可以配置该策略。</p></li></ul><h3 id="_3-csrf-跨站点请求伪造" tabindex="-1">3. CSRF 跨站点请求伪造 <a class="header-anchor" href="#_3-csrf-跨站点请求伪造" aria-label="Permalink to &quot;3. CSRF 跨站点请求伪造&quot;">​</a></h3><blockquote><p>CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作</p></blockquote><p>类型：</p><ol><li>GET类型的CSRF</li><li>POST类型的CSRF</li><li>链接类型的CSRF</li></ol><p>防御措施：</p><p>CSRF 攻击的本质是利用了 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充</p><ul><li>阻止不明外域的访问 <ul><li>同源检测</li><li>Samesite Cookie</li></ul></li><li>提交时要求附加本域才能获取的信息 <ul><li>CSRF Token</li><li>双重Cookie验证</li></ul></li></ul><h3 id="_4-ddos-分布式拒绝服务攻击" tabindex="-1">4. DDOS 分布式拒绝服务攻击 <a class="header-anchor" href="#_4-ddos-分布式拒绝服务攻击" aria-label="Permalink to &quot;4. DDOS 分布式拒绝服务攻击&quot;">​</a></h3><p>DDOS攻击准确来说其实不属于前端范畴，这里我们还是来介绍下，算是前端开发需要了解的一个东西吧</p><blockquote><p>DDoS(Distributed Denial of Service)即分布式拒绝服务攻击，是目前最为强大、最难以防御的攻击方式之一。要理解DDos，得先从DoS说起。最基本的DoS攻击就是利用合理的客户端请求来占用过多的服务器资源，从而使合法用户无法得到服务器的响应。DDoS攻击手段是在传统的DoS攻击基础之上产生的一类攻击方式，传统的DoS攻击一般是采用一对一的方式，当攻击目标的CPU速度、内存或者网络带宽等各项性能指标不高的情况下，它的效果是明显的。</p></blockquote>',22),c=[i];function r(s,n,d,S,p,u){return l(),o("div",null,c)}const q=e(t,[["render",r]]);export{_ as __pageData,q as default};
